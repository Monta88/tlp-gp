// Generated by Bisonc++ V4.08.00 on Sat, 15 Mar 2014 16:42:51 +0100
/*!
 * \file Parser.h
 * \brief This file have been generated by bisonc++ and completed by us
 * \author Alan BENIER, Martin LAGLEIZE, Nathan PRAT
 * \version 1.0
 * \date May 07th 2014
 */

#ifndef Parser_h_included
#define Parser_h_included

// $insert baseclass
#include "Parserbase.h"
// $insert scanner.h
#include "../scanner/Scanner.h"
// $insert preincludes
#include "../headers.h"


#undef Parser
class Parser: public ParserBase
{
    // $insert scannerobject
    Scanner d_scanner;
        
    public:
    
    /*!
	 * \brief Parsing function
	 * \return 0 if nothing went wrong
	 */
	int parse();
	
	/////////////////////////////////
	////     added functions     ////
	/////////////////////////////////
	
    /*!
	 * \brief Init the data
	 */
	void init() {
		m_data = new Data();
	}
	
	
	/*!
	 * \brief Copy the data of another Parser in order to parse another file (used to parse the problem file after having parsed the domain file)
	 * \param parser - the Parser object that contains the data to copy
	 */
	void setData(Parser * parser) {
		m_data = parser->getData();
	}
	
	/*!
	 * \brief Get the pointer to the data
	 * \return a pointer to the data
	 */
	Data * getData() {
		return m_data;
	}
	
	/*!
	 * \brief Set the name of the domain
	 * \param name - name of the domain
	 */
	void addDomain(std::string * name) {
		m_data->addDomain(name);
	}
	
	/*!
	 * \brief Verify if name is the name of the domain previously parsed
	 * \param name - name of the domain of the problem
	 */
	bool isDomain(std::string * name) {
		return m_data->isDomain(name);
	}
	
	/*!
	 * \brief Add the requirement req once read in :requirements
	 * \param req - Token of the requirement
	 * \return false if the requirement already exists, else true
	 */
	bool addRequirement(int req) {
		return m_data->addRequirement(req);
	}
	
	/*!
	 * \brief Verify if the requirement req has been announced in :requirements
	 * \param req - Token of the requirement
	 */
	bool isRequirement(int req) {
		return m_data->isRequirement(req);
	}
	
	/*!
	 * \brief Add the types once read in :types
	 * \param typedList_list - list of types : (typesList, parentTypesList)
	 * \return false something went wrong
	 */
	bool addTypes(std::vector<TypedList*> * typedList_list) {
		return m_data->addTypes(typedList_list);
	}
	
	/*!
	 * \brief Add the constants once read in :constants
	 * \param typedList_list - list of constants : (constantsList, typesList)
	 * \return false something went wrong
	 */
	bool addConstants(std::vector<TypedList*> * typedList_list) {
		return m_data->addConstants(typedList_list);
	}
	
	/*!
	 * \brief Add the predicates once read in :predicates
	 * \param name - the name of the predicate
	 *        typedList_list - list of parameters : (variablesList, typesList)
	 * \return false something went wrong
	 */
	bool addPredicate(std::string * name, std::vector<TypedList*> * typedList_list) {
		return m_data->addPredicate(name, typedList_list);
	}
	
	/*!
	 * \brief Add the functions once read in :functions
	 * \param function_skeleton_list - list of the functions' pairs of name and parameters
	 *        return_type - the type of the return (list for either representation)
	 * \return false something went wrong
	 */
	bool addFunctions(std::vector< std::pair< std::string*, std::vector<TypedList*>* >* > * function_skeleton_list, std::vector<std::string> * return_type) {
		return m_data->addFunctions(function_skeleton_list, return_type);
	}
	
	/*!
	 * \brief Add adurative-action once read in :durative-action
	 * \param name - name of the durative-action
	 *        typedList_list - parameters (variables) of the durative-action : (variablesList, typesList)
	 *        timed_GD - preconditions of the durative-action : list(pair(pair(fluentParameters, fluentName), precType))
	 *        cond_effect - effects of the durative-action : list(pair(pair(fluentParameters, fluentName), effectType))
	 * \return false something went wrong, such as a predicate that hasn't been defined
	 */
	bool addDurativeAction(std::string * name, std::vector<TypedList*> * typedList_list, float number, std::vector< std::pair< std::pair< std::vector< std::string > *, std::string *> * , int >* > * timed_GD, std::vector< std::pair< std::pair< std::vector< std::string > *, std::string *> * , int >* > * cond_effect) {
		return m_data->addDurativeAction(name, typedList_list, number, timed_GD, cond_effect);
	}
	
	/*!
	 * \brief Set the name of the problem
	 * \param name - name of the problem
	 */
	void addProblem(std::string * name) {
		m_data->addProblem(name);
	}
	
	/*!
	 * \brief Add the objects once read in :objects
	 *        and add the name of this object in m_object_list
	 * \param typedList_list - list of objects : (objectsList, typesList)
	 * \return false something went wrong
	 */
	bool addObjects(std::vector<TypedList*> * typedList_list) {
		return m_data->addObjects(typedList_list);
	}
	
	/*!
	 * \brief Add an init fluent once read in :init
	 * \param literal - fluent : pair(pair(parameters, name), positive)
	 *        at - time when this init is effctive
	 * \return false something went wrong, such as a fluent of which the predicate hasn't been defined
	 */
	bool addInit(std::pair< std::pair< std::vector< std::string > *, std::string *> *, bool > * literal, float at) {
		return m_data->addInit(literal, at);
	}
	
	/*!
	 * \brief Add the goal fluents once read in :goal
	 * \param pre_GD - list of fluents ()
	 * \return false something went wrong, such as a fluent of which the predicate hasn't been defined
	 */
	bool addGoals(std::vector< std::vector< std::pair< std::pair< std::vector< std::string > *, std::string *> * , int >* > * > * pre_GD) {
		return m_data->addGoals(pre_GD);
	}
	
	/*!
	 * \brief Add an initiated function once read in :init
	 * \param atomic_formula - name and parameters : pair(parameters, name)
	 *        number - the return of the initiated function
	 * \return false something went wrong, such as a function or an object or a constant that hasn't been defined
	 */
	bool addInitiatedFunction(std::pair< std::vector< std::string > *, std::string *> * atomic_formula, float number) {
		return m_data->addInitiatedFunction(atomic_formula, number);
	}
	
	/*!
	 * \brief Display the data (domain variables, problem variables, and errors) in stdout
	 */
	void display() {
		m_data->display();
	}
	
	/*!
	 * \brief Add a warning
	 * \param msg - message of the error
	 */
	void lexical_error(std::string msg) {
		m_data->lexical_error(msg);
	}
	
	/*!
	 * \brief Stop the execution and print the error message on stderr
	 * \param msg - message of the error
	 */
	void fatal_error(std::string msg) {
		m_data->fatal_error(msg);
	}
	
	/*!
	 * \brief Get the return of an initiated function
	 * \param name - the name of the function
	 *        list_term - list of parameters
	 * \return the return of the function, and -1.0 if the function hasn't been found in m_initiated_functions
	 */
	float g
	float getFunctionReturn(std::string * name, std::vector<std::string> * list_term) {
		return m_data->getFunctionReturn(name, list_term);
	}
	
    private:
		void error(char const *msg);	// called on (syntax) errors
		int lex();						// returns the next token from the
										// lexical scanner. 
		void print();					// use, e.g., d_token, d_loc

		// support functions for parse():
		void executeAction(int ruleNr);
		void errorRecovery();
		int lookup(bool recovery);
		void nextToken();
		void print__();
		void exceptionHandler__(std::exception const &exc);

		/////////////////////////////////
		////      our variables      ////
		/////////////////////////////////
		
		/*!< the data related to current file parsed */
		Data * m_data;
};


#endif
