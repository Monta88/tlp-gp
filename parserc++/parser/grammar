/* Parser PDDL */
/* pddl_3_1.y */
/* Authors : BENIER Alan, PRAT Nathan, LAGLEIZE Martin */

%scanner                ../scanner/Scanner.h
%scanner-token-function d_scanner.lex()

%start begin

%union
{
	int integer;
	float number;
	std::string * name;
	std::vector<std::string> * list_name;
	std::vector<float> * list_float;
	std::pair< std::vector< std::string > *, std::string *> * atomic_formula;
	std::vector<TypedList*> * typedList_list;
	std::pair< std::string*, std::vector<TypedList*>* > * function_skeleton;
	std::vector< std::pair< std::string*, std::vector<TypedList*> * > * > * function_skeleton_list;
	std::pair< std::pair< std::vector< std::string > *, std::string*> *, bool > * literal;
	std::vector< std::vector< std::pair< std::pair< std::vector< std::string > *, std::string *> * , int >* > * > * pre_GD;
	std::vector< std::pair< std::pair< std::vector< std::string > *, std::string *> * , int > * > * timed_GD;
	std::vector< std::pair< std::pair< std::vector< std::string > *, std::string *> * , int > * > * cond_effect;
	std::pair<std::pair<std::vector< std::pair< std::pair< std::vector< std::string > *, std::string *> * , int >* > *,std::vector< std::pair< std::pair< std::vector< std::string > *, std::string *> * , int >* > *> *, float> * da_def_body;
}

%token 	L_P
	R_P
	L_B
	R_B
	NS_T
	EQ
	SLASH
	STAR
	PLUS
	GT
	LT
	GOE
	LOE
	NUM
	DEFINE
	DOMAIN
	REQUIREMENTS
	STRIPS
	TYPING
	NEGATIVE_PRECONDITIONS
	DISJUNCTIVE_PRECONDITIONS
	EQUALITY
	EXISTENTIAL_PRECONDITIONS
	UNIVERSAL_PRECONDITIONS
	QUANTIFIED_PRECONDITIONS
	CONDITIONAL_EFFECTS
	FLUENTS
	NUMERIC_FLUENTS
	OBJECT_FLUENTS
	ADL
	DURATIVE_ACTIONS
	DURATION_INEQUALITIES
	CONTINUOUS_EFFECTS
	DERIVED_PREDICATES
	TIMED_INITIAL_LITERALS
	PREFERENCES
	CONSTRAINTS
	ACTION_COSTS
	TEMPORALLY_EXTENDED
	TYPES
	CONSTANTS
	PREDICATES
	FUNCTIONS
	NUMBER
	OBJECT
	EITHER
	ACTION
	PARAMETERS
	PRECONDITION
	EFFECT
	AND
	FORALL
	PREFERENCE
	OR
	NOT
	IMPLY
	EXISTS
	WHEN
	ASSIGN
	UNDEFINED
	SCALE_UP
	SCALE_DOWN
	INCREASE
	DECREASE
	DURATIVE_ACTION
	DURATION
	CONDITION
	AT
	OVER
	SUPPORTED
	FORBIDDEN
	SOMEWHERE
	ANYWHERE
	MINIMAL_DURATION
	TRANSITION_OVER
	MINUS
	START
	END
	ALL
	Q_M_DURATION
	Q_M
	DERIVED
	PROBLEM
	DD_DOMAIN
	OBJECTS
	INIT
	GOAL
	ALWAYS
	SOMETIME
	WITHIN
	AT_MOST_ONCE
	SOMETIME_AFTER
	SOMETIME_BEFORE
	ALWAYS_WITHIN
	HOLD_DURING
	HOLD_AFTER
	METRIC
	MINIMIZE
	MAXIMIZE
	TOTAL_TIME
	IS_VIOLATED
	LENGTH
	SERIAL
	PARALLEL
	TIMEPOINTS
	TIMEALIASES
	TIMECONSTRAINTS
	NAME

%%

begin:
	domain {}
	| problem {}
	;


/***************************************************/
/************** Domain Description *****************/
/***************************************************/		


/* <domain> */

domain:
	L_P DEFINE L_P DOMAIN name R_P domain_option1 {
		Parser::addDomain($5.name);
	}
	;

domain_option1:
	domain_option2
	| require_def domain_option2
	;

domain_option2:
	domain_option3
	| types_def domain_option3 {
		if (!Parser::isRequirement(TYPING)) Parser::lexical_error("Requirement :typing is needed");
	}
	;

domain_option3:
	domain_option4
	| constants_def domain_option4
	;

domain_option4:
	domain_option5
	| predicates_def domain_option5
	;

domain_option5:
	domain_option6
	| functions_def domain_option6 {
		if (!Parser::isRequirement(FLUENTS)) Parser::lexical_error("Requirement :fluents is needed");
	}
	;

domain_option6:
	domain_option7
	| constraints_domain domain_option7
	;

domain_option7:
	list_structure_def R_P
	;

/* <name> */

name:
	NAME {$$.name = new std::string(d_scanner.matched());}
	| AT {$$.name = new std::string("at");}
	| OVER {$$.name = new std::string("over");}
	| OBJECT {$$.name = new std::string("object");}
	;

/* <require-def> */

require_def:
	L_P REQUIREMENTS nvList_require_key R_P
	;

/* <require-key> */

require_key:
	STRIPS {
		Parser::addRequirement(STRIPS);
	}
	| TYPING {
		Parser::addRequirement(TYPING);
	}
	| NEGATIVE_PRECONDITIONS {
		Parser::addRequirement(NEGATIVE_PRECONDITIONS);
	}
	| DISJUNCTIVE_PRECONDITIONS {
		Parser::addRequirement(DISJUNCTIVE_PRECONDITIONS);
	}
	| EQUALITY {
		Parser::addRequirement(EQUALITY);}
	| EXISTENTIAL_PRECONDITIONS {
		Parser::addRequirement(EXISTENTIAL_PRECONDITIONS);
	}
	| UNIVERSAL_PRECONDITIONS {
		Parser::addRequirement(UNIVERSAL_PRECONDITIONS);
	}
	| QUANTIFIED_PRECONDITIONS {
		Parser::addRequirement(QUANTIFIED_PRECONDITIONS);
		Parser::addRequirement(EXISTENTIAL_PRECONDITIONS);
		Parser::addRequirement(UNIVERSAL_PRECONDITIONS);
	}
	| CONDITIONAL_EFFECTS {
		Parser::addRequirement(CONDITIONAL_EFFECTS);
	}
	| FLUENTS {
		Parser::addRequirement(FLUENTS);
		Parser::addRequirement(NUMERIC_FLUENTS);
		Parser::addRequirement(OBJECT_FLUENTS);
	}
	| NUMERIC_FLUENTS {
		Parser::addRequirement(NUMERIC_FLUENTS);
	}
	| OBJECT_FLUENTS {
		Parser::addRequirement(OBJECT_FLUENTS);
	}
	| ADL {
		Parser::addRequirement(STRIPS);
		Parser::addRequirement(TYPING);
		Parser::addRequirement(NEGATIVE_PRECONDITIONS);
		Parser::addRequirement(DISJUNCTIVE_PRECONDITIONS);
		Parser::addRequirement(EQUALITY);
		Parser::addRequirement(QUANTIFIED_PRECONDITIONS);
		Parser::addRequirement(CONDITIONAL_EFFECTS);
	}
	| DURATIVE_ACTIONS {
		Parser::addRequirement(DURATIVE_ACTIONS);
	}
	| DURATION_INEQUALITIES {
		Parser::addRequirement(DURATION_INEQUALITIES);
	}
	| CONTINUOUS_EFFECTS {
		Parser::addRequirement(CONTINUOUS_EFFECTS);
	}
	| DERIVED_PREDICATES {
		Parser::addRequirement(DERIVED_PREDICATES);
	}
	| TIMED_INITIAL_LITERALS {
		Parser::addRequirement(TIMED_INITIAL_LITERALS);
		Parser::addRequirement(DURATIVE_ACTIONS);
	}
	| PREFERENCES {
		Parser::addRequirement(PREFERENCES);
	}
	| CONSTRAINTS {
		Parser::addRequirement(CONSTRAINTS);
	}
	| ACTION_COSTS {
		Parser::addRequirement(ACTION_COSTS);
	}
	| TEMPORALLY_EXTENDED {
		Parser::addRequirement(TEMPORALLY_EXTENDED);
		Parser::addRequirement(DURATIVE_ACTIONS);
	}
	;

/* <types-def> */
types_def:
	L_P TYPES typed_list_name R_P {
		if(!Parser::addTypes($3.typedList_list))
			Parser::lexical_error("Error in :types");
	}
	;

/* <contants-def> */

constants_def:
	L_P CONSTANTS typed_list_name R_P {
		if (!Parser::addConstants($3.typedList_list))
			Parser::lexical_error("Error in :constants");
	}
	;

/* <predicates-def> */

predicates_def:
	L_P PREDICATES nvList_atomic_formula_skeleton R_P
	;

/* <atomic formula skeleton> */

atomic_formula_skeleton:
	L_P predicate typed_list_variable R_P {
		if (!Parser::addPredicate($2.name, $3.typedList_list)) {
			Parser::lexical_error("Error in :predicates");
		}
	}
	;

/* <predicate> */

predicate:
	name {
		$$.name = $1.name;
	}
	;

/* <variable> */

variable:
	Q_M name {
		$$.name = $2.name;
	 }
	;

/* <atomic function skeleton> */

atomic_function_skeleton:
	L_P function_symbol typed_list_variable R_P {
		$$.function_skeleton = new std::pair< std::string*, std::vector<TypedList*>* > ($2.name, $3.typedList_list);
	}
	;

/* <function-symbol> */

function_symbol:
	name {
		$$.name = $1.name;
	}
	;

/* <functions-def> */

functions_def:
	L_P FUNCTIONS function_typed_list_atomic_function_skeleton R_P {
		if (!Parser::isRequirement(FLUENTS)) Parser::lexical_error("Requirement :fluents is needed");
	}
	;

/* <function type> */

function_type:
	NUMBER {
		if (!Parser::isRequirement(NUMERIC_FLUENTS)) Parser::lexical_error("Requirement :numeric-fluents is needed");
		$$.list_name = new std::vector<std::string> ();
		$$.list_name->push_back("number");
	}
	| type {
		if (!Parser::isRequirement(TYPING)) Parser::lexical_error("Requirement :typing is needed");
		if (!Parser::isRequirement(OBJECT_FLUENTS)) Parser::lexical_error("Requirement :object-fluents is needed");
		$$.list_name = $1.list_name;
	}
	;

/* <constraints> */

constraints_domain:
	L_P CONSTRAINTS con_GD R_P {
		if (!Parser::isRequirement(CONSTRAINTS)) Parser::lexical_error("Requirement :constraints is needed");
	}
	;

/* <structure-def> */

structure_def:
	action_def
	| durative_action_def {
		if (!Parser::isRequirement(DURATIVE_ACTIONS)) Parser::lexical_error("Requirement :durative-actions is needed");
	}
	| te_durative_action_def {
		if (!Parser::isRequirement(TEMPORALLY_EXTENDED)) Parser::lexical_error("Requirement :temporally-extended is needed");
	}
	| derived_def {
		if (!Parser::isRequirement(DERIVED_PREDICATES)) Parser::lexical_error("Requirement :derived-predicates is needed");
	}
	;

/* <primitive-type> */

primitive_type:
	name {
		$$.name = $1.name;
	}
	| OBJECT {
		$$.name = new std::string("object");
	}
	;

/* <type> */

type:
	primitive_type {
		$$.list_name = new std::vector<std::string> ();
		$$.list_name->push_back(*$1.name);
	}
	| L_P EITHER nvList_primitive_type R_P {$$.list_name = $3.list_name;}
	;

/* <action_def> */

action_def:
	L_P ACTION action_symbol PARAMETERS L_P typed_list_variable R_P action_def_body R_P
	;

/* <action_symbol> */

action_symbol:
	name
	;

/* <action-def body> */

action_def_body:
	action_def_body_option1
	;

action_def_body_option1:
	action_def_body_option2
	| PRECONDITION emptyOr_pre_GD action_def_body_option2
	;

action_def_body_option2:
	/* empty */
	| EFFECT emptyOr_effect
	;

/* <pre-GD> */

pre_GD:
	pref_GD {
		$$.pre_GD = new std::vector< std::vector< std::pair< std::pair< std::vector< std::string > *, std::string *> *, int >* > * > ();
		$$.pre_GD->push_back($1.timed_GD);
	}
	| L_P AND list_pre_GD R_P {
		$$.pre_GD->insert($$.pre_GD->end(), $3.pre_GD->begin(), $3.pre_GD->end());
	}
	| L_P FORALL L_P typed_list_variable R_P pre_GD R_P {
		if (!Parser::isRequirement(UNIVERSAL_PRECONDITIONS)) Parser::lexical_error("Requirement :universal-preconditions is needed");
	}
	;

/* <pref-GD> */

pref_GD:
	GD {
		$$.timed_GD = $1.timed_GD;
	}
	| L_P PREFERENCE pref_GD_option1 {
		if (!Parser::isRequirement(PREFERENCES)) Parser::lexical_error("Requirement :preferences is needed");
	}
	;

pref_GD_option1:
	GD R_P
	| pref_name GD R_P
	;

/* <pref-name> */

pref_name:
	name
	;

/* <GD> */

GD:
	atomic_formula_term	{	
		$$.timed_GD = new std::vector< std::pair< std::pair< std::vector< std::string > *, std::string *> *, int >* >  ();	
		int init = 0b0;
		$$.timed_GD->push_back( new std::pair<std::pair< std::vector< std::string > *, std::string *> *, int > ($1.atomic_formula,init) );
	}	
	| literal_term {
		if (!Parser::isRequirement(NEGATIVE_PRECONDITIONS)) Parser::lexical_error("Requirement :negative-preconditions is needed");
		$$.timed_GD=$1.timed_GD;
	}
	| L_P AND list_GD R_P{
		$$.timed_GD=$3.timed_GD;
	}
	| L_P OR list_GD R_P {
		if (!Parser::isRequirement(DISJUNCTIVE_PRECONDITIONS)) Parser::lexical_error("Requirement :disjunctive-preconditions is needed");
	}
	| L_P NOT GD R_P {
		if (!Parser::isRequirement(DISJUNCTIVE_PRECONDITIONS)) Parser::lexical_error("Requirement :disjunctive-preconditions is needed");
		if ($3.timed_GD->front()->second & 0b01)
			$3.timed_GD->front()->second -= 0b01;
		else
			$3.timed_GD->front()->second += 0b01;
		$$.timed_GD=$3.timed_GD;
	}
	| L_P IMPLY GD GD R_P {
		if (!Parser::isRequirement(DISJUNCTIVE_PRECONDITIONS)) Parser::lexical_error("Requirement :disjunctive-preconditions is needed");
	}
	| L_P EXISTS L_P L_P typed_list_variable R_P R_P GD R_P {
		if (!Parser::isRequirement(EXISTENTIAL_PRECONDITIONS)) Parser::lexical_error("Requirement :existential-preconditions is needed");
	}
	| L_P FORALL L_P L_P typed_list_variable R_P R_P GD R_P {
		if (!Parser::isRequirement(UNIVERSAL_PRECONDITIONS)) Parser::lexical_error("Requirement :universal-preconditions is needed");
	}
	| f_comp {
		if (!Parser::isRequirement(NUMERIC_FLUENTS)) Parser::lexical_error("Requirement :numeric-fluents is needed");
	}
	;

/* <f-comp> */

f_comp:
	L_P binary_comp f_exp f_exp R_P
	;

/* <term> */

term:
	name	{
		$$.name=$1.name;
	}
	| variable	{
		$$.name=$1.name;
	}
	| function_term {
		if (!Parser::isRequirement(OBJECT_FLUENTS)) Parser::lexical_error("Requirement :object-fluents is needed");
	}
	;

/* <function-term> */

function_term:
	L_P function_symbol list_term R_P {
		if (!Parser::isRequirement(OBJECT_FLUENTS)) Parser::lexical_error("Requirement :object-fluents is needed");
	}
	;

/* <f-exp> */

f_exp:
	number {
		if (!Parser::isRequirement(NUMERIC_FLUENTS)) Parser::lexical_error("Requirement :numeric-fluents is needed");
		$$.number = $1.number;
	}
	| L_P binary_op f_exp f_exp R_P {
		if (!Parser::isRequirement(NUMERIC_FLUENTS)) Parser::lexical_error("Requirement :numeric-fluents is needed");
		switch ($2.integer) {
		case 1:
			$$.number = $3.number * $4.number;
			break;
		case 2:
			$$.number = $3.number + $4.number;
			break;
		case 3:
			$$.number = $3.number - $4.number;
			break;
		case 4:
			$$.number = $3.number / $4.number;
			break;
		default :
			Parser::fatal_error("Unkown binary operator");
		}
	}
	| L_P multi_op f_exp nvList_f_exp R_P {
		if (!Parser::isRequirement(NUMERIC_FLUENTS)) Parser::lexical_error("Requirement :numeric-fluents is needed");
		$$.number = $3.number;
		switch ($2.integer) {
		case 1:
			for (std::vector<float>::reverse_iterator it = $4.list_float->rbegin(); it != $4.list_float->rend(); ++it) {
				$$.number *= (*it);
			}
			break;
		case 2:
			for (std::vector<float>::reverse_iterator it = $4.list_float->rbegin(); it != $4.list_float->rend(); ++it) {
				$$.number += (*it);
			}
			break;
		default :
			Parser::fatal_error("Unkown multi operator");
		}
	}
	| L_P MINUS f_exp R_P {
		if (!Parser::isRequirement(NUMERIC_FLUENTS)) Parser::lexical_error("Requirement :numeric-fluents is needed");
		$$.number = - $3.number;
	}
	| f_head {
		if (!Parser::isRequirement(NUMERIC_FLUENTS)) Parser::lexical_error("Requirement :numeric-fluents is needed");
		$$.number = $1.number;
	}
	;

/* <number> */

number:
	NUM {
		$$.number = atof(d_scanner.matched().c_str());
	}
	;

/* <f-head> */

f_head:
	L_P function_symbol list_term R_P {
		$$.number = Parser::getFunctionReturn($1.name, $2.list_name);
	}
	| function_symbol {
		$$.number = Parser::getFunctionReturn($1.name, new std::vector<std::string> ());
	}
	;

/* <binary-op> */

binary_op:
	multi_op {
		$$.integer = $1.integer;
	}
	| MINUS {
		$$.integer = 3;
	}
	| SLASH {
		$$.integer = 4;
	}
	;

/* <multi-op> */

multi_op:
	STAR {
		$$.integer = 1;
	}
	| PLUS {
		$$.integer = 2;
	}
	;

/* <binary-comp> */

binary_comp:
	GT {
		$$.integer = 1;
	}
	| LT {
		$$.integer = 2;
	}
	| EQ {
		$$.integer = 3;
	}
	| GOE {
		$$.integer = 4;
	}
	| LOE {
		$$.integer = 5;
	}
	;

/* <effect> */

effect:
	L_P AND list_c_effect R_P
	| c_effect
	;

/* <c-effect> */

c_effect:
	L_P FORALL L_P typed_list_variable R_P effect R_P {
		if (!Parser::isRequirement(CONDITIONAL_EFFECTS)) Parser::lexical_error("Requirement :conditional-effects is needed");
	}
	| L_P WHEN GD cond_effect R_P {
		if (!Parser::isRequirement(CONDITIONAL_EFFECTS)) Parser::lexical_error("Requirement :conditional-effects is needed");
	}
	| p_effect
	;

/* <p-effect> */

p_effect:
	L_P NOT atomic_formula_term R_P {	
		$$.timed_GD= new std::vector< std::pair< std::pair< std::vector< std::string > *, std::string *> *, int >* > ();
		int init = 0b01;
		$$.timed_GD->push_back( new std::pair<std::pair< std::vector< std::string > *, std::string *> *, int > ($3.atomic_formula,init));
	}
	| atomic_formula_term	{			
		$$.timed_GD= new std::vector< std::pair< std::pair< std::vector< std::string > *, std::string *> *, int >* > ();
		int init = 0b0;
		$$.timed_GD->push_back( new std::pair< std::pair< std::vector< std::string > *, std::string *> *, int > ($1.atomic_formula,init));
	}
	| L_P assign_op f_head f_exp {
		if (!Parser::isRequirement(NUMERIC_FLUENTS)) Parser::lexical_error("Requirement :numeric-fluents is needed");
	}
	| L_P ASSIGN function_term term R_P {
		if (!Parser::isRequirement(OBJECT_FLUENTS)) Parser::lexical_error("Requirement :object-fluents is needed");
	}
	| L_P ASSIGN function_term UNDEFINED R_P {
		if (!Parser::isRequirement(OBJECT_FLUENTS)) Parser::lexical_error("Requirement :object-fluents is needed");
	}
	;

/* <cond-effect> */

cond_effect:
	L_P AND list_p_effect R_P {
		$$.cond_effect=$3.cond_effect;
	}
	| p_effect {
		$$.cond_effect=$1.cond_effect;
	}
	;

/* <assign-op> */

assign_op:
	ASSIGN
	| SCALE_UP
	| SCALE_DOWN
	| INCREASE
	| DECREASE
	;

/* <durative-action-def> */

durative_action_def:
	L_P DURATIVE_ACTION da_symbol PARAMETERS L_P typed_list_variable R_P da_def_body R_P {
		if(!Parser::addDurativeAction($3.name,$6.typedList_list,$8.da_def_body->second,$8.da_def_body->first->first,$8.da_def_body->first->second))
			Parser::lexical_error("Error in :durative-action");
	
	
	};

/* <da-symbol> */

da_symbol:
	name {
		$$.name = $1.name;
	}
	;

/* <da-def body> */

da_def_body:
	DURATION duration_constraint CONDITION emptyOr_da_GD EFFECT emptyOr_da_effect  { 
		std::pair< std::vector< std::pair< std::pair< std::vector< std::string > *, std::string *> *, int >* > *,std::vector< std::pair< std::pair< std::vector< std::string > *, std::string *> *, int >* > *>  *a = new std::pair<std::vector< std::pair< std::pair< std::vector< std::string > *, std::string *> *, int >* > *,std::vector< std::pair< std::pair< std::vector< std::string > *, std::string *> *, int >* > *> ($4.timed_GD,$6.cond_effect);

		$$.da_def_body=new std::pair< std::pair< std::vector< std::pair< std::pair< std::vector< std::string > *, std::string *> *, int >* > *,std::vector< std::pair< std::pair< std::vector< std::string > *, std::string *> *, int >* > *> *, float> (a, $2.number);
	};

/* <da-GD> */

da_GD:
	pref_timed_GD {
		$$.timed_GD=$1.timed_GD;
	}
	| L_P AND list_da_GD R_P {	
		$$.timed_GD=$3.timed_GD;		
	}
	| L_P FORALL L_P typed_list_variable R_P da_GD R_P {
		if (!Parser::isRequirement(UNIVERSAL_PRECONDITIONS)) Parser::lexical_error("Requirement :universal-preconditions is needed");
	}
	;

/* <pref-timed-GD> */

pref_timed_GD:
	timed_GD {
		$$.timed_GD=$1.timed_GD;			
	}
	| L_P PREFERENCE pref_name_option1 {
		if (!Parser::isRequirement(PREFERENCES)) Parser::lexical_error("Requirement :preferences is needed");
	}
	;

pref_name_option1:
	timed_GD R_P
	| pref_name timed_GD R_P
	;

/* <timed-GD> */

timed_GD:
	L_P AT time_specifier GD R_P {
		for (std::vector< std::pair< std::pair< std::vector< std::string > *, std::string *> *, int >* >::iterator it=$4.timed_GD->begin(); it != $4.timed_GD->end(); ++it){
			(*it)->second += 1 << $3.integer;
		}
		$$.timed_GD=$4.timed_GD;
	}
	| L_P OVER interval GD R_P {	
		for ( std::vector< std::pair< std::pair< std::vector< std::string > *, std::string *> *, int >* >::iterator it=$4.timed_GD->begin(); it != $4.timed_GD->end(); ++it){
			(*it)->second += 1 << $3.integer;
		}
		$$.timed_GD=$4.timed_GD;
	}
	;

/* <time-specifier> */

time_specifier:
	START {
		$$.integer = 1;
	}
	| END {
		$$.integer = 2;
	}
	;

/* <interval> */

interval:
	ALL {
		$$.integer = 3;
	}
	;

/* <duration-constraint> */

duration_constraint:
	L_P AND nvList_simple_duration_constraint R_P {
		if (!Parser::isRequirement(DURATION_INEQUALITIES)) Parser::lexical_error("Requirement :duration-inequalities is needed");
	}
	| L_P R_P { 
		$$.number=0.0; 
	}
	| simple_duration_constraint {
		$$.number=$1.number;
	}
	;

/* <simple-duration-constraint> */

simple_duration_constraint:
	L_P d_op Q_M_DURATION d_value R_P { 
		$$.number=$4.number;
	}
	| L_P AT time_specifier simple_duration_constraint R_P	{
		$$.number=$4.number;
	}
	;

/* <d-op> */

d_op:
	LOE {
		if (!Parser::isRequirement(DURATION_INEQUALITIES)) Parser::lexical_error("Requirement :duration-inequalities is needed");
	}
	| GOE {
		if (!Parser::isRequirement(DURATION_INEQUALITIES)) Parser::lexical_error("Requirement :duration-inequalities is needed");
	}
	| EQ
	;

/* <d-value> */

d_value:
	number {
		$$.number = $1.number;
	}
	| f_exp {
		if (!Parser::isRequirement(NUMERIC_FLUENTS)) Parser::lexical_error("Requirement :numeric-fluents is needed");
		$$.number = $1.number;
	}
	;

/* <da-effect> */

da_effect:
	L_P AND list_da_effect R_P { 
		$$.cond_effect=$3.cond_effect;
	}
	| timed_effect {
		$$.cond_effect=$1.cond_effect;
	}
	| L_P FORALL L_P typed_list_variable R_P da_effect R_P {
		if (!Parser::isRequirement(CONDITIONAL_EFFECTS)) Parser::lexical_error("Requirement :conditional-effects is needed");
	}
	| L_P WHEN da_GD timed_effect R_P {
		if (!Parser::isRequirement(CONDITIONAL_EFFECTS)) Parser::lexical_error("Requirement :conditional-effects is needed");
	}
	;

/* <timed-effect> */

timed_effect:
	L_P AT time_specifier cond_effect R_P { 
		for (std::vector< std::pair< std::pair< std::vector< std::string > *, std::string *> *, int > * >::iterator it = $4.cond_effect->begin(); it != $4.cond_effect->end() ; ++it){
			(*it)->second += 1 << $3.integer;
		}	
		$$.cond_effect=$4.cond_effect;
	}		
	| L_P AT time_specifier f_assign_da R_P {
		if (!Parser::isRequirement(NUMERIC_FLUENTS)) Parser::lexical_error("Requirement :numeric-fluents is needed");
	}
	| L_P assign_op_t f_head f_exp_t R_P {
		if (!Parser::isRequirement(CONTINUOUS_EFFECTS)) Parser::lexical_error("Requirement :continuous-effects is needed");
		if (!Parser::isRequirement(NUMERIC_FLUENTS)) Parser::lexical_error("Requirement :numeric-fluents is needed");
	}
	;

/* <f-assign-da> */

f_assign_da:
	L_P assign_op f_head f_exp_da R_P
	;

/* <f-exp-da> */

f_exp_da:
	L_P binary_op f_exp_da f_exp_da R_P
	| L_P multi_op f_exp_da nvList_f_exp_da R_P
	| L_P MINUS f_exp_da R_P
	| Q_M_DURATION  {
		if (!Parser::isRequirement(DURATION_INEQUALITIES)) Parser::lexical_error("Requirement :duration-inequalities is needed");
	}
	| f_exp
	;

/* <assign-op-t> */

assign_op_t:
	INCREASE
	| DECREASE
	;

/* <f-exp-t> */

f_exp_t:
	L_P STAR f_exp NS_T R_P
	| L_P STAR NS_T f_exp R_P
	| NS_T
	;

/* <derived-def> */

derived_def:
	L_P DERIVED atomic_formula_skeleton GD R_P
	;


/***************************************************/
/************** Problem Description ****************/
/***************************************************/


/* <problem> */

problem:
	L_P DEFINE L_P PROBLEM name R_P L_P DD_DOMAIN name R_P problem_option1 {
		if (!Parser::isDomain($9.name)) {
			Parser::lexical_error("Domain expected : " + (*$9.name));
		}
		else {
			Parser::addProblem($5.name);
		}
	}
	;

problem_option1:
	problem_option2
	| require_def problem_option2
	;

problem_option2:
	problem_option3
	| object_declaration problem_option3
	;

problem_option3:
	init goal problem_option4
	| init goal constraints_problem problem_option4 {
		if (!Parser::isRequirement(CONSTRAINTS)) Parser::lexical_error("Requirement :constraints is needed");
	}
	;

problem_option4:
	problem_option5
	| metric_spec problem_option5 {
		if (!Parser::isRequirement(NUMERIC_FLUENTS)) Parser::lexical_error("Requirement :numeric-fluents is needed");
	}
	;

problem_option5:
	R_P
	| length_spec R_P
	;

/* <object declaration> */

object_declaration:
	L_P OBJECTS typed_list_name R_P {
		if (!Parser::addObjects($3.typedList_list))
			Parser::lexical_error("Error in :objects");
	}
	;

/* <init> */

init:
	L_P INIT list_init_el R_P {}
	;

/* <init-el> */

init_el:
	literal_name {
		if (!Parser::addInit($1.literal, 0.))
			Parser::lexical_error("Error in :init");
	}
	| L_P AT number literal_name R_P {
		if (!Parser::isRequirement(TIMED_INITIAL_LITERALS)) Parser::lexical_error("Requirement :timed-initial-literals is needed");
		if (!Parser::addInit($4.literal, $3.number))
			Parser::lexical_error("Error in :init");
	}
	| L_P EQ basic_function_term number R_P {
		if (!Parser::isRequirement(NUMERIC_FLUENTS)) Parser::lexical_error("Requirement :numeric-fluents is needed");
		if (!Parser::addInitiatedFunction($3.atomic_formula, $4.number))
			Parser::lexical_error("Error in :init");
	}
	| L_P EQ basic_function_term name R_P {
		if (!Parser::isRequirement(OBJECT_FLUENTS)) Parser::lexical_error("Requirement :object-fluents is needed");
	}
	;

/* <basic-function-term> */

basic_function_term:
	function_symbol {
		$$.atomic_formula = new std::pair< std::vector< std::string > *, std::string *> (new std::vector<std::string> (), $1.name);
	}
	| L_P function_symbol list_name R_P {
		$$.atomic_formula = new std::pair< std::vector< std::string > *, std::string *> ($3.list_name, $2.name);
	}
	;

/* <goal> */

goal:
	L_P GOAL pre_GD R_P {
		if (!Parser::addGoals($3.pre_GD))
			Parser::lexical_error("Error in :goal");
	}
	;

/* <contraints> */

constraints_problem:
	L_P CONSTRAINTS pref_con_GD R_P {
		if (!Parser::isRequirement(CONSTRAINTS)) Parser::lexical_error("Requirement :constraints is needed");
	}
	;

/* <pref-con-GD> */

pref_con_GD:
	L_P AND list_pref_con_GD R_P
	| L_P FORALL L_P typed_list_variable R_P pref_con_GD R_P {
		if (!Parser::isRequirement(UNIVERSAL_PRECONDITIONS)) Parser::lexical_error("Requirement :universal-preconditions is needed");
	}
	| L_P PREFERENCE pref_con_GD_option1 {
		if (!Parser::isRequirement(PREFERENCES)) Parser::lexical_error("Requirement :preferences is needed");
	}
	| con_GD
	;

pref_con_GD_option1:
	con_GD R_P
	| pref_name con_GD R_P
	;

/* <con-GD> */

con_GD:
	L_P AND list_con_GD R_P
	| L_P FORALL L_P typed_list_variable R_P con_GD R_P
	| L_P AT END GD R_P
	| L_P ALWAYS con2_GD R_P
	| L_P SOMETIME con2_GD R_P
	| L_P WITHIN number con2_GD R_P
	| L_P AT_MOST_ONCE con2_GD con2_GD R_P
	| L_P SOMETIME_AFTER con2_GD con2_GD R_P
	| L_P SOMETIME_BEFORE con2_GD con2_GD R_P
	| L_P ALWAYS_WITHIN number con2_GD con2_GD R_P
	| L_P HOLD_DURING number number con2_GD R_P
	| L_P HOLD_AFTER number con2_GD R_P
	;

/* <con2-GD> */

con2_GD:
	con_GD
	| GD
	;

/* <metric-spec> */

metric_spec:
	L_P METRIC optimization metric_f_exp R_P {
		if (!Parser::isRequirement(NUMERIC_FLUENTS)) Parser::lexical_error("Requirement :numeric-fluents is needed");
	}
	;

/* <optimization> */

optimization:
	MINIMIZE
	| MAXIMIZE
	;

/* <metric-f-exp> */

metric_f_exp:
	L_P binary_op metric_f_exp metric_f_exp R_P
	| L_P multi_op metric_f_exp nvList_metric_f_exp R_P
	| L_P MINUS metric_f_exp R_P
	| number
	| L_P function_symbol list_name R_P
	| function_symbol
	| TOTAL_TIME
	| L_P TOTAL_TIME R_P
	| L_P IS_VIOLATED pref_name R_P {
		if (!Parser::isRequirement(PREFERENCES)) Parser::lexical_error("Requirement :preferences is needed");
	}
	;

/* <length-spec> */

length_spec:
	L_P LENGTH length_spec_option1
	;

length_spec_option1:
	length_spec_option2
	| L_P SERIAL integer R_P length_spec_option2
	;

length_spec_option2:
	R_P
	| L_P PARALLEL integer R_P R_P
	;

/* <integer> */

integer:
	NUM {
		$$.number = atof(d_scanner.matched().c_str());
	}
	;


/***************************************************/
/*************** Temporally_Extended ***************/
/***************************************************/


/* <te-durative-action-def> */

te_durative_action_def:
	L_P DURATIVE_ACTION da_symbol PARAMETERS L_P typed_list_variable R_P DURATION duration_constraint te_durative_action_def_option1
	;

te_durative_action_def_option1:
	TIMEPOINTS L_P list_te_timepoint R_P te_durative_action_def_option2
	| te_durative_action_def_option2
	;

te_durative_action_def_option2:
	TIMEALIASES L_P list_te_timealias R_P te_durative_action_def_option3
	| te_durative_action_def_option3
	;

te_durative_action_def_option3:
	TIMECONSTRAINTS L_P list_te_timeconstraint R_P CONDITION emptyOr_te_da_GD EFFECT emptyOr_te_da_effect R_P
	| CONDITION emptyOr_te_da_GD EFFECT emptyOr_te_da_effect R_P
	;

/* <te-timepoint> */

te_timepoint:
	time_specifier
	| name
	;

/* <te-timealias> */

te_timealias:
	L_P te_interval_name te_interval_def R_P
	;

/* <te-interval-name> */

te_interval_name:
	interval
	| name
	;

/* <te-interval-def> */

te_interval_def:
	bracket te_timepoint_op te_timepoint_op bracket
	;

/* <bracket> */

bracket:
	L_B
	| R_B
	;

/* <te-timeconstraint> */

te_timeconstraint:
	L_P binary_comp te_timepoint_op te_timepoint_op R_P
	;

/* <te-timepoint-op> */

te_timepoint_op:
	te_timepoint
	| d_value
	| L_P binary_op te_timepoint_op te_timepoint_op R_P
	;

/* <te-interval> */

te_interval:
	te_interval_name
	| te_interval_def
	;

/* <te-da-GD> */

te_da_GD:
	te_pref_timed_GD
	| L_P AND list_te_da_GD R_P
	| L_P FORALL L_P typed_list_variable R_P te_da_GD R_P {
		if (!Parser::isRequirement(UNIVERSAL_PRECONDITIONS)) Parser::lexical_error("Requirement :universal-preconditions is needed");
	}
	;

/* <te-pref-timed-GD> */

te_pref_timed_GD:
	te_timed_GD
	| L_P PREFERENCE te_pref_timed_GD_option1 {
		if (!Parser::isRequirement(PREFERENCES)) Parser::lexical_error("Requirement :preferences is needed");
	}
	;

te_pref_timed_GD_option1:
	te_timed_GD R_P
	| pref_name te_timed_GD R_P
	;

/* <te-timed-GD> */

te_timed_GD:
	L_P AT te_timepoint_op GD R_P
	| L_P OVER te_interval GD R_P
	| L_P SUPPORTED te_interval GD R_P
	| L_P FORBIDDEN te_interval GD R_P
	| L_P SOMEWHERE te_interval GD R_P
	| L_P ANYWHERE te_interval GD R_P
	| L_P MINIMAL_DURATION d_value ANYWHERE te_interval GD R_P
	;

/* <te-da-effect> */

te_da_effect:
	L_P AND list_te_da_effect R_P
	| te_timed_effect
	| L_P FORALL L_P typed_list_variable R_P te_da_effect R_P {
		if (!Parser::isRequirement(CONDITIONAL_EFFECTS)) Parser::lexical_error("Requirement :conditional-effects is needed");
	}
	| L_P WHEN da_GD te_timed_effect R_P {
		if (!Parser::isRequirement(CONDITIONAL_EFFECTS)) Parser::lexical_error("Requirement :conditional-effects is needed");
	}
	;

/* <te-timed-effect> */

te_timed_effect:
	L_P AT te_timepoint_op cond_effect R_P
	| L_P AT te_timepoint_op f_assign_da R_P {
		if (!Parser::isRequirement(NUMERIC_FLUENTS)) Parser::lexical_error("Requirement :numeric-fluents is needed");
	}
	| L_P assign_op_t f_head f_exp_t R_P  {
		if (!Parser::isRequirement(CONTINUOUS_EFFECTS)) Parser::lexical_error("Requirement :continuous-effects is needed");
		if (!Parser::isRequirement(NUMERIC_FLUENTS)) Parser::lexical_error("Requirement :numeric-fluents is needed");
	}
	| te_modality
	;

/* <te-modality> */

te_modality:
	L_P AT te_timepoint_op cond_effect R_P
	| L_P OVER te_interval cond_effect R_P
	| L_P SUPPORTED te_interval cond_effect R_P
	| L_P FORBIDDEN te_interval cond_effect R_P
	| L_P SOMEWHERE te_interval cond_effect R_P
	| L_P ANYWHERE te_interval cond_effect R_P
	| L_P MINIMAL_DURATION d_value ANYWHERE te_interval cond_effect R_P
	| L_P TRANSITION_OVER te_interval cond_effect R_P
	;




/***************************************************/
/****************** Miscellaneous ******************/
/***************************************************/


/* <function typed list (x)> */

function_typed_list_atomic_function_skeleton:
	/* empty */
	| nvList_atomic_function_skeleton MINUS function_type function_typed_list_atomic_function_skeleton {
		if (!Parser::addFunctions($1.function_skeleton_list, $3.list_name)) {
			Parser::lexical_error("Error in :function");
		}
	}
	| nvList_atomic_function_skeleton {
		if (!Parser::isRequirement(NUMERIC_FLUENTS)) Parser::lexical_error("Requirement :numeric-fluents is needed");
		if (!Parser::addFunctions($1.function_skeleton_list, new std::vector<std::string> ())) {
			Parser::lexical_error("Error in :function");
		}
	}
	;


/* <typed list (x)> */

typed_list_name:
	list_name {
		$$.typedList_list = new std::vector<TypedList*> ();
		if ($1.list_name->size() == 0) {
			// if end of typed_list
		} else {
			// if no type
			std::vector<std::string> * list_name = new std::vector<std::string> ();
			list_name->push_back("object");
			$$.typedList_list->push_back(new TypedList(list_name, $1.list_name));
		}
	}
	| nvList_name MINUS type typed_list_name {
		if (!Parser::isRequirement(TYPING)) Parser::lexical_error("Requirement :typing is needed");
		$4.typedList_list->push_back(new TypedList($3.list_name, $1.list_name));
		$$.typedList_list = $4.typedList_list;
	}
	;

typed_list_variable:
	list_variable {
		$$.typedList_list = new std::vector<TypedList*> ();
		if ($1.list_name->size() == 0) {
			// if end of typed_list
		} else {
			// if no type
			std::vector<std::string> * list_name = new std::vector<std::string> ();
			list_name->push_back("object");
			$$.typedList_list->push_back(new TypedList(list_name, $1.list_name));
		}
	}
	| nvList_variable MINUS type typed_list_variable {
		if (!Parser::isRequirement(TYPING)) Parser::lexical_error("Requirement :typing is needed");
		$4.typedList_list->push_back(new TypedList($3.list_name, $1.list_name));
		$$.typedList_list = $4.typedList_list;
	}
	;

/* <emptyOr (x)> */

emptyOr_pre_GD:
	L_P R_P
	| pre_GD
	;

emptyOr_effect:
	L_P R_P
	| effect
	;

emptyOr_da_GD:
	L_P R_P	{
		$$.timed_GD =new std::vector< std::pair< std::pair< std::vector< std::string > *, std::string *> *, int >* >();
	}
	| da_GD	{
		$$.timed_GD= $1.timed_GD; 
	}
	;

emptyOr_da_effect:
	L_P R_P	{
		$$.cond_effect = new std::vector< std::pair< std::pair< std::vector< std::string > *, std::string *> *, int >* >();
	}
	| da_effect {
		$$.cond_effect=$1.cond_effect;
	}
	;

emptyOr_te_da_GD:
	L_P R_P
	| te_da_GD
	;

emptyOr_te_da_effect:
	L_P R_P
	| te_da_effect
	;

/* <litteral (t)> */

literal_term:
	atomic_formula_term{		
		$$.timed_GD= new std::vector< std::pair< std::pair< std::vector< std::string > *, std::string *> *, int >* >  ();	
		int init = 0b0;
		$$.timed_GD->push_back( new std::pair< std::pair< std::vector< std::string > *, std::string *> *, int > ($1.atomic_formula,init) );
	}
	| L_P NOT atomic_formula_term R_P{
		$$.timed_GD= new std::vector< std::pair< std::pair< std::vector< std::string > *, std::string *> *, int >* > ();	
		int init = 0b0;
		$$.timed_GD->push_back( new std::pair< std::pair< std::vector< std::string > *, std::string *> *, int >($1.atomic_formula,init) );
	}
	;

literal_name:
	atomic_formula_name {		
		$$.literal = new std::pair<std::pair< std::vector< std::string > *, std::string *> * , bool >($1.atomic_formula, true);
	}
	| L_P NOT atomic_formula_name R_P {
		$$.literal = new std::pair<std::pair< std::vector< std::string > *, std::string *> * , bool >($3.atomic_formula, false);
	}
	;

/* <atomic formula (t)> */

atomic_formula_term:
	L_P predicate list_term R_P {
		$$.atomic_formula= new std::pair< std::vector< std::string > *, std::string *>($3.list_name,$2.name);
	}
	| L_P EQ term term R_P {
		if (!Parser::isRequirement(EQUALITY)) Parser::lexical_error("Requirement :equality is needed");
	}
	;

atomic_formula_name:
	L_P predicate list_name R_P {
		$$.atomic_formula = new std::pair< std::vector< std::string > *, std::string *>($3.list_name,$2.name);
	}
	| L_P EQ name name R_P {
		if (!Parser::isRequirement(EQUALITY)) Parser::lexical_error("Requirement :equality is needed");
	}
	;

/* <nvList_A> (= non void list) -> <A>+ */

nvList_require_key:
	require_key list_require_key
	;

nvList_name:
	name list_name {
		$2.list_name->push_back(*$1.name);
		$$.list_name = $2.list_name;
	}
	;

nvList_atomic_formula_skeleton:
	atomic_formula_skeleton list_atomic_formula_skeleton
	;

nvList_variable:
	variable list_variable {
		$2.list_name->push_back(*$1.name);
		$$.list_name = $2.list_name;
	}
	;
	
nvList_atomic_function_skeleton:
	atomic_function_skeleton list_atomic_function_skeleton {
		$$.function_skeleton_list = $2.function_skeleton_list;
		$$.function_skeleton_list->push_back($1.function_skeleton);
	}
	;

nvList_primitive_type:
	primitive_type list_primitive_type {
		$2.list_name->push_back(*$1.name);
		$$.list_name = $2.list_name;
	}
	;

nvList_f_exp:
	f_exp list_f_exp {
		$$.list_float = $2.list_float;
		$$.list_float->push_back($1.number);
	}
	;

nvList_simple_duration_constraint:
	simple_duration_constraint list_simple_duration_constraint
	;

nvList_f_exp_da:
	f_exp_da list_f_exp_da
	;

nvList_metric_f_exp:
	metric_f_exp list_metric_f_exp
	;

/* <list_A> -> <A>* */

list_structure_def:
	/* empty */
	| structure_def list_structure_def
	;

list_require_key:
	/* empty */
	| require_key list_require_key
	;

list_name:
	/* empty */ {
		$$.list_name = new std::vector<std::string> ();
	}
	| name list_name {
		$2.list_name->push_back(*$1.name);
		$$.list_name = $2.list_name;
	}
	;

list_atomic_formula_skeleton:
	/* empty */		
	| atomic_formula_skeleton list_atomic_formula_skeleton
	;

list_variable:
	/* empty */ {
		$$.list_name = new std::vector<std::string> ();
	}
	| variable list_variable {
		$2.list_name->push_back(*$1.name);
		$$.list_name = $2.list_name;
	}
	;

list_atomic_function_skeleton:
	/* empty */ {
		$$.function_skeleton_list = new std::vector< std::pair< std::string*, std::vector<TypedList*>* >* > ();
	}
	| atomic_function_skeleton list_atomic_function_skeleton {
		$$.function_skeleton_list = $2.function_skeleton_list;
		$$.function_skeleton_list->push_back($1.function_skeleton);
	}
	;

list_primitive_type:
	/* empty */ {
		$$.list_name = new std::vector<std::string> ();
	}
	| primitive_type list_primitive_type {
		$2.list_name->push_back(*$1.name);
		$$.list_name = $2.list_name;
	}
	;

list_pre_GD:
	/* empty */ {
		$$.pre_GD = new std::vector< std::vector< std::pair< std::pair< std::vector< std::string > *, std::string *> *, int >* > * > ();
	}
	| pre_GD list_pre_GD {
		$$.pre_GD->insert($$.pre_GD->end(), $2.pre_GD->begin(), $2.pre_GD->end());
	}
	;

list_term:
	/* empty */ {
		$$.list_name = new std::vector<std::string>();
	}
	| term list_term { 
		$$.list_name=$2.list_name;
		$$.list_name->push_back(*$1.name);
	}
	;

list_GD:
	/* empty */ {
		$$.timed_GD = new std::vector< std::pair< std::pair< std::vector< std::string > *, std::string *> *, int >* >();
	}
	| GD list_GD {
		$$.timed_GD = $2.timed_GD; 
		for (std::vector< std::pair< std::pair< std::vector< std::string > *, std::string *> *, int >* >::iterator it = $1.timed_GD->begin() ; it != $1.timed_GD->end() ; ++it){
			$$.timed_GD->push_back(*it);
		}
	}
	;

list_f_exp:
	/* empty */ {
		$$.list_float = new std::vector<float>;
	}
	| f_exp list_f_exp {
		$$.list_float = $2.list_float;
		$$.list_float->push_back($1.number);
	}
	;

list_c_effect:
	/* empty */
	| c_effect list_c_effect
	;

list_p_effect:
	/* empty */ {
		$$.cond_effect= new std::vector< std::pair< std::pair< std::vector< std::string > *, std::string *> *, int >* >();
	}
	| p_effect list_p_effect {
		$2.cond_effect->insert( $2.cond_effect->end(), $1.cond_effect->begin(), $1.cond_effect->end() );
		$$.cond_effect=$2.cond_effect; 
	}
	;

list_te_timepoint:
	/* empty */
	| te_timepoint list_te_timepoint
	;

list_te_timealias:
	/* empty */
	| te_timealias list_te_timealias
	;

list_te_timeconstraint:
	/* empty */
	| te_timeconstraint list_te_timeconstraint
	;

list_te_da_GD:
	/* empty */
	| te_da_GD list_te_da_GD
	;

list_te_da_effect:
	/* empty */
	| te_da_effect list_te_da_effect
	;

list_da_GD:
	/* empty */ {
		$$.timed_GD = new std::vector< std::pair< std::pair< std::vector< std::string > *, std::string *> *, int >* >();
	}
	| da_GD list_da_GD {

	$$.timed_GD = $1.timed_GD; 
		for (std::vector< std::pair< std::pair< std::vector< std::string > *, std::string *> *, int >* >::iterator it = $2.timed_GD->begin() ; it != $2.timed_GD->end() ; ++it){
			$$.timed_GD->push_back(*it);
		}
	}
	;

list_simple_duration_constraint:
	/* empty */
	| simple_duration_constraint list_simple_duration_constraint
	;

list_da_effect:
	/* empty */	{
		$$.cond_effect= new std::vector< std::pair< std::pair< std::vector< std::string > *, std::string *> *, int > * >();
	}
	| da_effect list_da_effect{
		$$.cond_effect = $2.cond_effect; 
		for (std::vector< std::pair< std::pair< std::vector< std::string > *, std::string *> *, int >* >::iterator it = $1.cond_effect->begin() ; it != $1.cond_effect->end() ; ++it){
			$$.cond_effect->push_back(*it);
		}
	}
	;

list_f_exp_da:
	/* empty */
	| f_exp_da list_f_exp_da
	;

list_init_el:
	/* empty */
	| init_el list_init_el
	;

list_pref_con_GD:
	/* empty */
	| pref_con_GD list_pref_con_GD
	;

list_con_GD:
	/* empty */
	| con_GD list_con_GD
	;

list_metric_f_exp:
	/* empty */
	| metric_f_exp list_metric_f_exp
	;


/***************************************************/
/*********************** End ***********************/
/***************************************************/

